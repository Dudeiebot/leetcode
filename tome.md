
Just tome.md for my all everything into


So here basically we have the algorithm for leetcode and some explainantion following them



- Duplicate Number (we use map to get things done here or some len shii by ranging twice but memeory shii can come in)
- Valid anagram (we use map also and performs increment on it, then we range through the key and value of the increment)
- Valid palindrome (a very kind of strange lens calculation that goes through the string)
- Single number appearance (Using the bitwise operator will give us the constant time and space needed and very fast also, the bitwise operator here have a kind of calculation in it and it ir represented with the (^) symbol)
- Two Sums in a array and returning the indices of the nos, here we can use brute force which result to O(n2) and also we can use our hashmap to solve it which will make it faster and help save time O(n)
- Finding the nos palindrome using the equation half = half * 10 + x % 10, and then remember it is a loop, so it get to go through all till x > half then we check for the equality in the palindrome or if it is an odd nos we check for the mod with the equality
- converting romans to integer and here we have two approach to it, we loop to check the length of our input string and then we store the result to a map, the other way is replacing the bizzare numerals like (4, 9, 40, 90, 400 and 900) and then we keep on replacing them in instances where they come up
- Here we get our longest prefix, firstly we range through the first word, then range for other words in the remaining slice, if i is equal to length of word or words[i] is not equal to firstlet[i], it then return the firstlet from 0 to i where it stop. We are returning firstlet at the end because it may be the longest prefix also from the beginning.
- checking parenthesis, we are using the LIFO approach of a stack and we range through our input, then we have a big if statement that check for opening bracket first and append it to the stack then we pop out the closing bracket and compare it with the pairs map(or the opening brackets). return false if they are different or return true
- merging two linked sorted list, we create a temp node which is a ref to listNode, we rep current node as the tempNode. we compare between the values and we bring it up to the tempNode through the help of currentNode
- Removing duplicates in a sorted array, here we have to go through the array and use a pointer to make our changes and perform it in constant space of time. the pointer is being incremented when they are not the same and also the right value is moved to the left value.
- Removing the duplicate element of val (x) in an array, it is the same like the later just that here we are given a val and checking for the duplicates in the array, firstly we create pur pointer and go through the nums and we check if each num is not the same with the value provided, then we move the right to the left if they are not and they increment our pointer, which we later return 
- Removing elements and removing duplicates elements are the same because it uses the same two pointer approach with increment/decrement on it, for constant space of time 
- Checking the index in which a substring is, in a mainstring, we can use the fast route with the go library strings.Index and then we can use a pointer that point to the end(but not directly the end cause that means we are wasting time), then we use the array indexing library to do the equality(which is this i: i+len(substring))
- Searching for insert in an array and returning the index if it is in the array or where it is supposed to be in the array, We are using O(log n) here which is the binary search (it goes through the middle and does the search from there) 
- we are returning the length of the last word in a sentence, so first we take away all the trailing space then we count back the last word
- We are incrementing the last word in an array and when the last array is 9 we do the normal addition (which is add 1 to the left side and make unit 0), dont forget that we need to start from the last unit. We start our for loop from the end and perform our addition.
- We are adding two binary nos together, so we will just use the normal addition of two binary nos(not greater than 2)
- mySqrt used to get the square of a number without using the standard library, we use binary search and check from the middle, the we multiply it twice to see if it is right
- Dynamic programming which is related to the fibonacci series, we have a nos of ways to climb a step. If there are no step at all there will be only one way(not to climb at all). so the no(ways) == no(ways) - 1 + no(ways) - 2
- removing duplicates from a linked list, we assign a pointer to our list and it get updated
- Merging 2 sorted array of length (m + n) and length (n), and the final sorted should not be returned but instead be sorted in nums1, so here we basically swap values and compare between the 2 arrays
- Inorder traversal is one of the DFS techniques that use 0(n) time complexity, which traverse the left node first to the root and the right node last. I am using the iterative techniques here we create a stack to store our current elements, the stack append when the current is not nil and pop out when the current is nil 
- PreOrder traversal, here we put the root first followed by the left and right, we can also use iterative and recursion method also. 
- PostOrder traversal, here we put the root Val last. We first traverse the left and also the right and finally the root is added last, we can use both iterative and recursion method here also
- IsSame Tree, we check for the base case and if the root (p.Val, q.Val) are not equal then we check for same left and same right
- IsSymmetry(checking if the tree is mirror like), here we create a helper func dfs that check the difference between the left and the right node because we cant use the root node alone to check if they are mirror like. This func is effective (left.Right, right.Left && left.Left, right.Right) which check for opposite sides of the tree
- for finding the maximum depth in a tree, we perform a recursion to the left and right of the tree, then add 1 to the max of the height(root.Left && root.Right). Always remember the base case for all this algorithm or you can get it wrong there
- converting a sorted array to a binary tree is straight forward with recursion and that is by dividing the array into 2, and representing the root as the middle, then follows the remaining value of root.right and root.left
- checking for balanced tree, we go create 3 helper func max, abs and dfs. the max func check between our max height on both the left and right, the abs check for the diff between the left and the right and the dfs is use to introduce the new int we added to the program 
- Minimum height, we create a helper func that check for the Minimum values and also when all the remaining value are nil, it give us the second output as answer then we add it to the root
- the path sum is checked from the deduction of the targetSum from the root.Val and then a recursion is performed on it till root.Left and root.Right become nil
- Generating Pascal triangle, we know the first array is 1 and the second is 1, 1 then we can also use that information in generating the remaining ones.
- Getting the row index of a pascal triangle can be easy with out pointer approach and appending the value to our slice
- The best time stock is can eaily be done with a two pointer(left and right) approach techniques that goes from the beginning to the end
- max profit from a stock, we are also using the 2 pointer approach only that here there is no else in our code and thatt means the buy goes through loop across all 
- finding the single number among number that are 3 in an array, this is different from the first single nos and among two same nos in an array, we can use the bruteforce and also the constant space of time method here. the xor operator for the constant space of time goes through the nums and create a 2 pointer which can be calculated ones ^= (num & ^twos) and same for the second pointer
- cycle in a linked list, we use the floyd tortiose and hare method, which means we have 2 pointer called slow and fast. Fast goes 2* faster than slow, we return true when fast and slow get to meet or false if they don't meet at all. Perfect illustration is a circular track 
- detecting the cycle in the linked list can be done with hashmap
- Getting Intersection Node can come in 2 ways using the hashmap, we save a ListNode on the map and we range the other one to check the equality. For good optimization and adequate memory we can create two pointer, where a and b will intersect then go through each other one by one and this is possible because a doesnot get to nil  and b also doesnot get to nil and when it does a becomes headB and b becomes headA and we return one of them when they are the same
- so this is a mathematics question, that have the equation and also some rune conversion
- the opposite of the conversion to string, this one the conversion is to int and they are not pretty hard just mathematics conversion and ranging through
- so here we are going to be using hashmap and boyer moore algorithm, they are both straight forward and easily understandable also
- reversing uint32 here, we have to do some bit manipulating and by doing this, we loop through our nos and for every loop we shift the result left once perform a bitwise operation and shift the num to the right once
- hamming weight is when we return the non-zero part of a number, and we are using unsigned int here so we check till the num is not equal to 0 then we mod the last digit and move the num to the right once. Finally we return count
- is HAPPY alogrithm does some mathematical calculation to check if something pass or not, check leetcode for more understanding on it (Leetcode 202) 
- for removing elements in a linked list that are the same with our provided value, we just create 2 pointer and a dummy node that start before the beginning adn range through all. (dont worry about my util.ListNode, i created a package in the folder struct to avoid me writing the struct type all the time)
- isIsmorphic can be check with 2 different map back and forth just like the definition of ismorphic
- To reverse a list we can use 2 pointer for the iterative version, and that is just creating a list outside and then swapping values(and remember curr.Next = prev and not curr.Val because it is an int)
- contains Nearby Duplicates can be done by creating 2 pointers or by using hashmap, either will work well but the hashmap is more memory efficient
- To count all the node, we can easily traverse through them all but let jsut use recursion for faster out and easy code
- Inverse a binary tree, we are going to use recursion with a pointer that exchange the left and right, then we return root. Always remember to add the base Case of root == nil {return nil}
- Summary Ranges does some array ranging and does string conversion then append the result to a slice
- is power of Twos can be gotten through the mod of 2 and then we range through it till our temp = 1 (temp is equal to our nos), then to get the last nos we will check the mod of 2 and then divide it by 2, which is the same also for isPowerOfThree and also powerOfFour
- checking if a linked list is a palindrome, we can use 2 ways and that is, (1.) We convert our linkedlist to an array and then use a 2 pointer to check if they are the same but another way to do it, (2.) We will first of all check the middle of an array and then we will reverse the array from the middle then we compare the newly reversed array with the first array
- BinarytreePath, we range through and append to the array, then we use recursion
- addDigit, we add numbers that are less than 10 till they become a single num, and that can be done with checking the mod of 9 on those num because of some mathematical knowledge
- isUgly are number whose prime factors are limited to 2, 3 and 5. So here we basically check if the num provided is divisible by 2, 3 and 5 and finally return 1, basically we range through the newly created array and then do the mod and division on them
- missing nums out of a lise of num in an array can be very tricky especiall when we have to use constant space of time, we solved this by getting the total from 0 to n(len of the array) in the array and this can be done with (total = (n + 1) * n/2) then we range through the array and delete those nums
- for finding the world pattern we remove all the space in the other string, then we create 2 map and range through each to compare
- countBits can be solved with the dynamic programming techniques and here we have a count that check for our significant bit (1,2,4,8,16) and in this significant bit there is a recursion that occur there
- reverse strings in a byte array, we are just going to use the 2 pointer and start our right at the end and left at the beginning, we swap values and we are good to go
- reverse the vowels in a string, we create a helper function that check for vowels(isVowels which return boolean and take in rune), we convert our string to rune and we compare with our 2 pointers and then finally we convert the rune collected to string
- for finding the intersection, we use a map to check for duplicates and then we range through the second also to append then check for eqality with (seen[num]=false), the other one is intersetion of 2 array also just that this one must show as many time it is being shown in the 2 array
- for finding if a number is a valid square, we cna use binary search that check from the middle to the left and then to the right, in a for loop where l < r
- i have the guessing api in the guess folder
- for canConstruct, we provide 2 string and then we check if one can be created form the other one. I used hashmap here 
- first Unique character, i used hashmap also but there is another method with array and i will do it also
- finding the difference between two string, we can use hashmap like i said in the code but i am using bit manipulation techniques here, which stores the answer in a result. 
- for finding the subsequence from s in a longer string t, we use the 2 pointer approach that start at the samne point and then l goes +1 if they are equal and if they are not equal, r only goes + 1, then we equate when l equals the len of s
- Reading the Binary Watch, we first of all remember there is hour and minutes on the watch and the best thing to do is to range through the hour and the minutes, then we remember to count the oneBits with the go built in library called (bits.oneCount) or another way is to create a helper func that countBit also (and that is easy by declaring a pointer then using the % etc....). the if turnedOn == our convertedbit added together, we append with the formatting (%d:%02d)
- for finding the sum of the left Leaves, we will use recursion here which return nill if root is nil and we then go through root.Left make sure it is not nil and root.Left.Left is equal to nil and root.Left.Right is equal to nil. our var res created is then equal to the root.Left.Val, we do same for the recursion back to back
- Converting a number to hex is easy and straightforward, we have our constant and check for the base cases (which are when n == 0) and also when n < 1 (we convert it to the negative of 1). Then we range from the till n is greater than 0 then we perform our mod 16 on the number  and the remainder is being check before we add it to our string
- for finding the longest palindrome, we are using hashmap here which will have a rune and int count on it, we range through the hashmap to check for all even nos and then add them to the ans we created, we have an else statement also that implicitly check for odd number and what it does is that it minus 1 from all odd number and add them up togther and finally we add 1 to the ans if it have odd nos on it
- fizzbuzz is just a simple if and else statement or switch case statement
- for finding the thirdmax, we are suppose to sort but we are not sorting here because it can be expensive for larger array, and here what we are just doing is initialising the new 3 var to math.MinInt64 and then when are greater than occurs num are swapped and given new values etc..........
- Adding strings, this is just the normal addition process where we carry through and all
- we are going to be using strings.FieldsFunc here that takes in (a string and a rune which is space, which is unicode.IsSpace) it seperates them and then we range through it with a count increment
- for arrange coins, we can use the gauss formula and also binary search and the bruteforce method, for the binary search we perform a calc m * (m + 1)/2 and if the calc is greater then we deduct r from m - 1 else our res = m also l = m + 1. we return res finally here. for the bruteforce we just perform some subtraction and addition
- for finding all duplicates here, we are going to use the absolute that kind of convert a nos to negative it is been seen and when it is seen again, we append the index
- for finding the missing number in an array or maybe the disappeared number, we are creating an array with the equal amount of lenth like the num array from the function. we range through and sort it, if there are nos that are not there they are given zero and then we know the disappeared number like that, we range through the res and create a counter also(the ocunter is used to know the amount of disappeared num in the array)
- assign cookies can be called a compare solution and that is why we need to sort before we run it through and from  sorting it we are all good to go.
- for finding the Hamming distance between two integers is the number of positions at which the corresponding bits are different, and we are going to do these by finding the XOR of the 2 number, then we initiate a count which we loop through and perform an AND operation  on it, we right shift it upon each loop
- Repeated string, we perform a kind of concaqtenation on the strings and that is by doubling it (from index 1 to index 0 : len - 1)  then we check if it contains the string in the concatenated string
- for finding the complement, we create a temp that is equial to 1 then we left it with 1 and the exclusive or it with 1, it is in a for loop the check till it is creater than the n created then xor the num and the newly created temp to give us our result
- for license formatting we are going firstly convert all the strings to Upper and the replace all "-" to space "", then we check for the mod between the len and the int. If we get 0, it means we divide it to equal part and then concatenate it
- for finding max consectuives one, we create 2 pointer that keep both nos of 1 and hte max nos of 1, at the end we do some checking and balancing
- for construct rectangle, we need to firstly find the square root of the area, then we range through it, then any where the area % sqrt is equal to 0 we return and if not we decrease by 1
- this is type of game whereby you have the time series you have to start and end in an array [the start, the end but this does not have end] so now the duration is being added to both side, let say for instance timeSeries[1,2] with duration 2, the person start at 1 and end at 2 then start at 2 again anf end at 4 the time used to fight is then 3
- for finding the next greater element we create a mao and a new array, the map stores the nums2 with there equivalent position in the array, then we go through the nums1 and then perform some math there
- for find word in a certain keyboard constant, we much first of all put all the keyboard const in a row(1,2,3) then we go through each word and each letter in the word and cross check it with the row, and if they are all in the same row we append to the new array res created
- we recursiv Inorder traversal here to find the mode(most frequently occured element)
- for finding the the base 7 of a num, it is the normal way we do it. you % and divide aand for the negative nos here we are going to convert to normal int and use concat to do the remaining
- for finding relative ranks, we first store the element in a map with their equivalent position and then sort in descending order. we can now use switch case to put the 1-3 in their position and dont forget we check it with the map also
- we have only 6 perfect nos but we can use the range method to go through it and some mathematical calculation
- we know how fibnacci work with it frequence, we just do some ranging and swapping values
- to detect capital use we are going to be using 2 ways, the first one is creating 2 variable and check for if both are true(d 2 variables are allCaps anbd remainingPart) and the other way is creating another helper func that check for each byte level of (c >= 'A' && c <= 'Z') then we range through the word and check for inequality
- reversing a certain amount of string and skipping 2 * k part, we convert it to byte and then range through the byte individually we skipped the amount needed to skip and then reverse what we need to revers
- for finding the longest uncommon subsequence, we check if the string are the same then we return -1, and then if len of a is  greater than len ob then we return max
- for finding the Minimum diff in a binary tree, we are going to be using the recursive Inorder helper function, we assing prev to -1 (which  is used to flag to indicate the first node being visited) and minDiff is give the maximum possible int in go value. so if prev is still -1 it means this is the first Node and then it being calculated like that in all
- for finding the diameter of a binary tree, we are going to be using dfs recursive search to go through the node and we need to be check the max because we dont want to return the min but the max diameter
- for check Records, we are going to be using 2 pointers that increment when they notice the character and return their their necessary bool when it more or less
- for finding reverse word, we first convert it to slice of byte because string are immutable and then we perform a for operation that checks when char[i] == space and then we stop to perform the string reverse. the last index here help us to find the start of the word and is minorly important
- we are finding the max depth in a nth-nary tree and this is not a binary tree, remember that. So we have to range through all  the children Node and then check for the max among themn and finally they are added to the maxDepth value
- array pair sum(we are pairing the arrays and finding the min value of the pairs and adding them together, we want to also get the max value and not the 2nd best)so to do that we are going to sort the array first and that range in 2 part each of the array then add it up with a var we created called sum
- for finding the tilt in a binary tree (The tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values), and we are going to create a helper func that traverse through the binary treeNode and then we perform the abs diff between the left and right
- for reshaping a 2d(matrix) array, we are going to create another 2d array to keep our res, then we range through the 2d array given to us and then we equate them to each other. We check for if we have gotten to the end of the column given to us then we increment reow then and return res
- for finding if the sub Tree is in the tree, we are using our func isSameTree then we recure on the root.Left with subRoot, root.Right with subtree
- distributing candy type, we need a hashmap and then we check for the lens with some certain instruction following it
- preorder nth nary tree, we are using the iterative and recursive version, and the recursive version is straightforward but the iterative version we are creating a stack and pushing root to it first then we pop the last element from the stack and append it to the res also for the remaining we go recursively go through the children node from the back and then add it to the stack and pop it to append to the res 
- PostOrder nth nary tree, we are using the iterative calculation, the recursive version is straightforward, but the iterative version we are creating a stack and pushing root to it first then we pop the last element from the stack and append it to the res from the front, also for the remaining we go through the children node from the front and then add it to the stack and pop it to append to the res 
- for finding the longest harminous subsequence(We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1), we create a map and iterate over their occurence, then we check for difference of 1 and find the max of it
- for finding the maxCount, we range through the double array and range through each x and y on it then we find the min val of it each and finally multiply then together
- for finding restaurant, we are going to be  using hashMap and maxInt value because we want to find the minimal index value or the same index value in both list
- can replace flowerBed, is making sure there are no flowers planted adjacent to each other, and that is why checking some base case is important and when we do that, checking the left side and the right side also is important
- for merging 2 trees, we are using the recursion method and we check for the base case(if root1 is nil return root2 and vice-versa), we then point value and add both value from root1 and root2 together
- for finding the maximum products, we are going to first of all sort the array nums, do some products on 3 of the nos and  finding the max among them
- for finding the average between each node in the tree, check for base case go on to looping till the node is equal to 0, we check for each part of the node and divide by the node nos. then we append our result to a slice we created
- for finding the max average, we are finding the maximum average in the array with a certain nos k, and that is done by checking when the k nos is reached also when we reach the max among the array. find the average and then we done
- for finding error nums, we are checking for doubles and then we create a new slice that stores both the double element and and the next one that need to be incremented.
- finding target in a binary tree, we are using the recursion way in and checking it with a map for storing values
- judging circle is for checking a completed cycle, and it just easy cause we want to see if our x and y are back to 0, 0 after going U,D,L,R. which are technically up, down, left and right.
- for finding the second min Value in a treeNode, we are using the level order traversal and when doing that we compare it with the most maximum value in an int, we don more comparing also because we are checking for the second minimal value
- for finding the lowest common increasing subsequence, and we need 2 pointers because of instances where they are all the same number throughout. 
- valid palindrome with removing at most one letter from the string, we are going to be Using a helper func isPalindrome that takes in the string, left, and right then return bool, int, int. we check for eqality at the beginning and the end but most importantly we are going to be removing some certain letters and checking again if they equqlly palindrome.
- for calculating the points in a baseball game, we are just using switch case for our array and performing each operation on each cases
- for checking the alternating bits in a binary nos, we are going to first of all convert the nos to binary and then we check if the last nos is the same as the next and if it is we return false and if not we return true
- for finding the substring in a binary nos, we are creating var to track the consecutive counts of the current and the previous string, then a res is being incremented upon each substring available
- for finding a certain value in a BST, we can use the recursion traverse but we are using a pointer to our root node, it is checking with the value(either using our if or switch statement), and most importantly remember that in a BST, values on the left subtree are smaller than the current node's value (and that is why we go to the left if our val is less than temp pointer Value)
- finding the shortest sub array, we look at the most common element using 2 maps (one and keeping track of the starting index with the num and the other track of each encountered element so far).
- to Lower, we can use the standard library strings.ToLower or maybe the another breakdown method where we convert the string to byte and use the ascii values in converting to lower letter
- for checking is one bits character, we go through it and check if it have a last 0 and it is a one bit or otherwise
- The pivot index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right, and we are doing that through the  array method and some calculation.
- to check a number from left to right, if it self dividing we are going to creating a helper function that checks it and we do that like this (for example 128, 128/1, 128/2. 128/8 and that mean 128 is self dividing)
- for finding the next greater elements, we are going to be using binary search and dont forget we are using byte which is just the ASCII values of our strings, so therefore it is easy to perform all those operation like it is numbers
- minCostClimibing stairs, we can use the same approach with the Climbing stairs and it is dynamic programming through out, but here the most important thing is that we are finding the min(so we are going to be using the util.Min that we created for finding the min value)
- finding dominant index is just going through a nums of array and finding if the secondMax number is atleast twice the max number, and we can do the using a for loop function in getting the max Number and the secondMax, finally we do the necessarily checking the and return the appropriate result
- for countingPrimeSetBits, we are going to create a helper function that count bits and when it do that we check it with our map primes that have the primes listed and if true count is being incremented and given result
- nums of jewel in stones, we are going to range through the stong and use our stdLib strings.Contain to check if it is inside or we can range through the both jewel and stone twice and check if they are equal
- rotate string, we convert the string to rune array and then we range through it and the detach a element and append to the arr then we compare and return the necessary boolean
- for checking for unique morseCode representation, we are going to be using the hashMap defining our morseMap and also a morseSet thst keep trrsck of our morseCode then we return the length of our morseSet
- finding the number of lines in a width, we are going to use our range function and also for this (each - 'a', to get the index that is why we are using each-'a', if the letter is a then a - 'a' = 0 which is index 0)
- for the mostCommon Word , we are creating 2 maps that store the banned word and the other that store each word in the paragraph (the paragraph is being converted to remove all FieldsFunc) and then we check for max and return the maxWord
- finding the shortest path to a char, we are going to use 3 steps, step 1; initialize arr, step2; first sweep that give us some negative values becaues of i-c(pos) and the final  step which sweep correct from the back and output result
- to convert a string to goat latin(it is important to know what a goat latin words look like), we store our vowel in a map and any occurence, string concatenation occurs and finally we trim whitespaces
- for finding the large Group positions in a strings and returning the double 2d array, so we are going to be using 2 pointer and checking for instances where it occurs more than 3 or equal 3 and then we return the result
- for fliping image and inverting it in a 2d array, we are going to be fliping all 0 to 1 and left to right and any occurence that is left behind without left and right we just flip it and return our new 2d array
- checking if a rectangle overlap, we check for the overlap rectangle snd that is the left, right, up and down which are the max and min of each rectangle side. Then  if right and up is greater than right and down we return an overLap or false
- same as overlap but here we are going to be checking the area of the overlap and it all make sense all together
- deleting a letter we encouter behind #, we convert to rune slice, then our helper function help us to check for the occurrence of '#' in the string and the letters behind are removed from the string then we check with our if the string is still the same and finally return the necesary bool.
-  this is a cashier type of mathematics, we are going to be using the switch statement and it is going to range through the bills and check if there is change for all customers and return the necessary bool.
- to transpose a matrix, we will intialize our row and cols(which are the len of the matrix and the len of the first index in the matrix) then we range through the matrix and before we do that remember to intialize each rows of our result with the correct number of cols
- to test binary gaps(binary gaps means we are going to be checking maximum distance of 1 adjacent in a binary number) so because we are giving our int in base 10, we convert it to base 2 first, then range through it with a counter and a max that we at last return
- for getting the similar leafes node in 2 treeNode, we are going to be using depth first search and not bfs (because bfs is layer by layer and sometimes the leaf node may be in a different layer) The dfs helper function is going to append all the leaf node and we use reflect.DeepEqual to check if the are equal
- buddystring are strings where there are 2 letters swappable in s to give goal(not more than or less than) those are our base cases we need to check and make sure before returning our bool. check if the length are equal form the beginning, go on further to check if the diff is more than 2 or less than. so instances where there are no difference, it uses the map to store records of s and if there are duplicated it return the necessary bool
- for the projection area in a 3d cube, then we range through the row and the col. We grid[j][i] and grid[i][j] > maxCol and maxRow we equate it to maxRow and maxCol and increment the res if grid[j][i] is not equal to zero, we add it all up together to get our result
- finding middle Node in  ListNode, we are using the fast and slow approach(the slow move at 1 pace and the fast move at 2* pace). we cvheck if fast is not nil and fast.Next is not nil then slow = slow.Next and f = f.Next.Next, we are returning s because there is a thoery that when fast get to the end then slow will get to the middle.
- for checking the uncommon in sentence, we can use a map to store all the strings and increment any strign appearing twice and if it appear once we append it to a result
- for fair candySwap (confusing kinda)
- is Montonic in checking whether the nums[j] and nums[i] are not more than 1 either increasing or decreasing, so we are going to be intialiozing our var increasing and decreasing to false var and check the necessary nums when we range through it
- increasing bst is just rearranging the binary tree in an increasing order, and we are going to be using the dfs also the recursive way
- sorting this array, we are putting the even to the left and the odd to the right. so we are going to be using 2 arrays(namely odd and even and we are going to be storing both even numbers and odd numbers in each array ) then finally we are going to be arranging it at the end,keeping the even to the left and the odd to the right.
- reversing only letters in a sentence, so we are going to be using 2 pointers and using unicode.IsLetter to check for the letters. Then we are going to be moving on if it is not a letter but definitely swap values if it is a letter, so initially we convert it to a rune array and finally convert it to a string for the result
- sorting array by parity in a different way than the other array by parity, we are arranging the array in such a way that if nums[i] is even then i is even or if nums[i] is odd then i is odd also. So here we are going to be using a 2 pointer and intialize them to 0 and 1 which are both the first even and odd number then we are going to be checking for n then incrementing both l and r by 2
- for checking the number of unique emails in an array of emails, we can use two approach to it, first the one which we use our standard library to get things done quickly and the second is the one which we just use the normal data structure approach to get things done. So basically we just want to check the nos of email that messages can get sent to out of the array of mails(so basically the checking in the mails are just when we come accross "." we concatenate it but when we come across "+" we ignore the remaining before the domain "@")
- range of the sum between low and high in a binary tree, so we are going to be checking if the root.Val is greater than high we recurse back and forth for it
- we are creating an array with the length of string + 1, then we go on to check for D and I in the string, and for all encounter of I we return low(which is intialized to 0) and increment it, Upon encountering 'D' we decrement high(which is the len of s)
- here we are going to be checking if the string are lexographically sorted, and it is not by row but by column, we are juct going to be converting the byte to int and checking them on the ascii table if the follow the lexographical order.
- checking with alien dictionary, we want to just make sure the words are lexographically ordered. so first w ehvae to be sure shorter word comes first and then we store all our aliend word in a dict, we are going to ranging throughn the words and you know each letter
- repeatedNtimes in a nums, it is just checking for the nums that are repeated in an array, that means the occurrence of the num is more than 1
- for largest perimeter, what we should remember is that the sum of 2 side must always be greater than the other side, so we can practically be checking if the sides meet the criteria(for the looping, we are going to be doing it once or twice)
- this is for checking if all the node in the tree is having equal values and it can be done the recursive way or the normal way of iteration
- adding an array to an int and returning the result in array back can be kind of tricky, if we want to converting them one by one, it is going to consume a lot of time and we dont want to consume a lot of memeory and spend a lot of time, so we are going to be using our array tha comes with it and just be swapping values and also using our mod and division to get new values
- sorting squares in an array. So here we are going to be using binary search instead of the normal standard library that can consume a lot of memory and time also, so we are going to be using 3 var (our binary search left and right and i that goes through the new array) i is our new pointers left and right is squared and we checking for the biggest and put it in i because our i start from the end of the array
