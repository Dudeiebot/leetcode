
Just tome.md for my all everything into


So here basically we have the algorithm for leetcode and some explainantion following them



- Duplicate Number (we use map to get things done here or some len shii by ranging twice but memeory shii can come in)
- Valid anagram (we use map also and performs increment on it, then we range through the key and value of the increment)
- Valid palindrome (a very kind of strange lens calculation that goes through the string)
- Single number apperance (Using the bitwise operator will give us the constant time and space needed and very fast also, the bitwise operator here have a kind of calculation in it and it ir represented with the (^) symbol)
- Two Sums in a array and returning the indices of the nos, here we can use brute force which result to O(n2) and also we can use our hashmap to solve it which will make it faster and help save time O(n)
- Finding the nos palindrome using the equation half = half * 10 + x % 10, and then remember it is a loop, so it get to go through all till x > half then we check for the equality in the palindrome or if it is an odd nos we check for the mod with the equality
- converting romans to integer and here we have two approach to it, we loop to check the length of our input string and then we store the result to a map, the other way is replacing the bizzare numerals like (4, 9, 40, 90, 400 and 900) and then we keep on replacing them in instances where they come up
- Here we get our longest prefix, firstly we range through the first word, then range for other words in the remaining slice, if i is equal to length of word or words[i] is not equal to firstlet[i], it then return the firstlet from 0 to i where it stop. We are returning firstlet at the end because it may be the longest prefix also from the beginning.
- checking parenthesis, we are using the LIFO approach of a stack and we range through our input, then we have a big if statement that check for opening bracket first and append it to the stack then we pop out the closing bracket and compare it with the pairs map(or the opening brackets). return false if they are different or return true
- merging two linked sorted list, we create a temp node which is a ref to listNode, we rep current node as the tempNode. we compare between the values and we bring it up to the tempNode through the help of currentNode
- Removing duplicates in a sorted array, here we have to go through the array and use a pointer to make our changes and perform it in constant space of time. the pointer is being incremented when they are not the same and also the right value is moved to the left value.
- Removing the duplicate element of val x in an array, it is the same like the later just that here we are given a val and checking for the duplicates in the array, firstly we create pur pointer and go through the nums and we check if each num is not the same with the value provided, then we move the right to the left if they are not and they increment our pointer, which we later return 
- Removing elements and removing duplicates elements are the same because it uses the same pointer approach with increment on it, for constant space of time 
- Checking the index in which a substring is in a mainstring, we can use the fast route with the gi library strings.Index and then we can use a pointer that point to the end(but not directly the end cause that means we are wasting time), then we use the array indexing library to do the equality(which is this i: i+len(substring))
- Searching for insert in a array and we are returning the index if it is in the array or where it is supposed to be in the array, We are using the O(log n) here which is the binary search (it goes through the middle and does the search from there) 
- we are returning the legth of the last word in a sentences, so firstly take away all the trailing spaces then we count back the last word
- We are incrementing the last word in an array and when the last array is 9 we do the normal addition, we dont forget that we need to start from the last unit. We start our for loop from the end and perform our addition.
- We are adding two binary nos together, so we will just use the normal addition of two binary nos(not greater than 2)
- mySqrt used to get the square of a number without using the standard library, we use binary search and check from the middle, the we multiply it twice to see if it is right
- Dynamic programming which is related to the fibonacci series, we have a nos of ways to climb a step. If there are no step at all there will be only one way(not to climb at all). so the no(ways) == no(ways) - 1 + no(ways) - 2
- removing duplicates from a linked list, we assign a pointer to our list and it get updated
- Merging 2 sorted array of length (m + n) and length (n), and the final sorted ahould not be returned but instead be sorted in nums1, so here we basically swap values and compare between the 2 arrays
- Inorder traversal is one of the DFS techniques that use 0(n) time complexity, which traverse the left node first to the root and the right node last. I am using the iterative techniques here we create a stack to store our current elements, the stack append when the current is not nil and pop out when the current is nil 
- PreOrder traversal, here we put the root first followed by the left and right, we can also use iterative and recursion method also. 
- PostOrder traversal, here we put the root Val last. We first traverse the left and also the right and finally the root is added last, we can use both iterative and recursion method here also
- IsSame Tree, we check for the base case and if the root (p.Val, q.Val) are not equal then we check for same left and same right
- IsSymmetry(checking if the tree is mirror like), here we create a helper func dfs that check the difference between the left and the right node because we cant use the root node alone to check if they are mirror like. This func is effective (left.Right, right.Left && left.Left, right.Right) which check for opposite sides of the tree
- for finding the maximum depth in a tree, we perform a recursion to the left and right of the tree, then add 1 to the max of the height(root.Left && root.Right). Always remember the base case for all this algorithm or you can get it wrong there
- converting a sorted array to a binary tree is straight forward with recursion and that is by dividing the array into 2, and representing the root as the middle, then follows the remaining value of root.right and root.left
- checking for balanced tree, we go create 3 helper func max, abs and dfs. the max func check between our max height on both the left and right, the abs check for the diff between the left and the right and the dfs is use to introduce the new int we added to the program 
- Minimum height, we create a helper func that check for the Minimum values and also when all the remaining value are nil, it give us the second output as answer then we add it to the root
- the path sum is checked from the deduction of the targetSum from the root.Val and then a recursion is performed on it till root.Left and root.Right become nil
- Generating Pascal triangle, we know the first array is 1 and the second is 1, 1 then we can also use that information in generating the remaining ones.
- Getting the row index of a pascal triangle can be easy with out pointer approach and appending the value to our slice
- The best time stock is can eaily be done with a two pointer(lef and right) approach techniques that goes from the beginning to the end
- max profit from a stock, we are also using the 2 pointer approach only that here there is no else in our code and thatt means the buy goes through loop across all 
- finding the single number among number that are 3 in an array, this is different from the first single nos among two same nos in an array, we can use the bruteforce and also the constant space of time method here. the xor operator for the constant space of time goes through the nums and create a 2 pointer which then equal ones ^= (num & ^twos) and same for the secodn pointer
- cycle in a linked list, we use the floyd tortiose and hare method, which means we have 2 pointer called slow and fast. Fast goes 2* faster than slow, we return true when fast and slow get to meet or false if they dont meet at all. Perfect illustration is a circular track 
- detecting the cycle in the linked list can be done with hashmap
- Getting Intersection Node can come in 2 ways using the hashmap, we save a ListNode on the map and we range the other one to check the equality. For good optimization and adequate memory we can create two pointer, where a and b will intersect then go through each other one by one and this is possible because a doesnot get to nil  and b also doesnot get to nil and when it does a becomes headB and b becomes headA and we return one of them when they are the same
- so this is a mathematics question, that have the equation and also some rune conversion
- the opposite of the conversion to string, this one the conversion is to int and they are not pretty hard just mathematics conversion and ranging through
- so here we are going to be using hashmap and boyer moore algorithm, they are both straight forward and easily understandable also
- reversing uint32 here, we have to do some bit manipulating and by doing this, we loop through our nos and for every loop we shift the result left once perform a bitwise operation and shift the num to the right once
- hamming weight is when we return the non-zero part of a number, and we are using unsigned int here so we check till the num is not equal to 0 then we mod the last digit and move the num to the right once. Finally we return count
- is HAPPY alogrithm does some mathematical calculation to check if something pass or not, check leetcode for more understanding on it (Leetcode 202) 
- for removing elements in a linked list that are the same with our provided value, we just create 2 pointer and a dummy node that start before the beginning adn range through all. (dont worry about my util.ListNode, i created a package in the folder struct to avoid me writing the struct type all the time)
- isIsmorphic can be check with 2 different map back and forth just like the definition of ismorphic
- To reverse a list we can use 2 pointer for the iterative version, ann that is just creating a list outside and then swapping values(and remember curr.Next = prev and not curr.Val because it is an int)
- contains Nearby Duplicates can be done by creating 2 pointers or by using hashmap, either will work well but the hashmap is more memory efficient
- To count all the node, we can easily traverse through them all but let jsut use recursion for faster out and easy code
- Inverse a binary tree, we are going to use recursion with a pointer that exchange the left and right, then we return root. Always remember to add the base Case of root == nil {return nil}
- Summary Ranges does some array ranging and does string conversion then append the result to a slice
- is power of Twos can be gotten through the mod of 2 and then we range through it till our temp = 1 (temp is equal to our nos), then to get the last nos we will check the mod of 2 and then divide it by 2, which is the same also for isPowerOfThree and also powerOfFour
- checking if a linked list is a palindrome, we can use 2 ways and that is, (1.) We convert our linkedlist to an array and then use a 2 pointer to check if they are the same but another way to do it, (2.) We will first of all check the middle of an array and then we will reverse the array from the middle then we compare the newly reversed array with the first array
- BinarytreePath, we range through and append to the array, then we use recursion
- addDigit, we add numbers that are less than 10 till they become a single num, and that can be done with checking the mod of 9 on those num because of some mahtematical knowledge
- isUgly are number whose prime factors are limited to 2, 3 and 5. So here we basically check if the num provided is divisible by 2, 3 and 5 and finally return 1, basically we range through the newly created array and we then do the mod and division on them
- missing nums out of a lise of num in an array can be very tricky especiall when we have to use constant space of time, we solved this by getting the total from 0 to n(len of the array) in the array and this can be done with (total = (n + 1) * n/2) then we range through the array and delete those nums
- for finding the world pattern we remove all the space in the other string, then we create 2 map and range through each to compare
- countBits can be solved with the dynamic programming techniques and here we have a count that check for our significant bit (1,2,4,8,16) and in this significant bit there is a recursion that occur there
- reverse strings in a byte array, we are just going to use the 2 pointer and start our right at the end and left at the beginning, we swap values and we are good to go
- reverse the vowels in a string, we create a helper function that check for vowels(isVowels which return boolean and take in rune), we convert our string to rune and we compare with our 2 pointers and then finally we convert the rune collected to string
- for finding the intersection, we use a map to check for duplicates and then we range through the second also to append then check for eqality with (seen[num]=false), the other one is intersetion of 2 array also just that this one must show as many time it is being shown in the 2 array
- for finding if a number is a valid square, we cna use binary search that check from the middle to the left and then to the right in a for loop where l < r
- i have the guessing api in the guess folder
- for canConstruct, we provide 2 string and then we check if one can be created form the other one. I used hashmap here 
- first Unique character, i used hashmap also but there is another method with array and i will do it also
- finding the difference between two string, we can use hashmap like i said in the code but i am using bit manipulation techniques here, which stores the answer in a result. 
- for finding the subsequence from s in a longer string t, we use the 2 pointer approach that start at the samne point and then l goes +1 if they are equal and if they are not equal, r only goes + 1, then we equate when l equals the len of s
- Reading the Binary Watch, we first of all remember there is hour and minutes on the watch and the best thing to do is to range through the hour and the minutes, then we remember to count the oneBits with the go built in library called (bits.oneCount) or another way is to create a helper func that countBit also (and that is easy by declaring a pointer then using the % etc....). the if turnedOn == our convertedbit added together, we append with the formatting (%d:%02d)
- for finding the sum of the left Leaves, we will use recursion here which return nill if root is nil and we then go through root.Left make sure it is not nil and root.Left.Left is equal to nil and root.Left.Right is equal to nil. our var res created is then equal to the root.Left.Val, we do same for the recursion back to back
- Converting a number to hex is easy and straightforward, we have our constant and check for the base cases (which are when n == 0) and also when n < 1 (we convert it to the negative of 1). Then we range from the till n is greater than 0 then we perform our mod 16 on the number  and the remainder is being check before we add it to our string
- for finding the longest palindrome, we are using hashmap here which will have a rune and int count on it, we range through the hashmap to check for all even nos and then add them to the ans we created, we have an els statement also that implicitly check for odd number and what it does is that it minus 1 from all odd number and add them up togther and finally we add 1 to the ans if it have odd nos on it
- fizzbuzz is just a simple if and else statement or switch case statement
- for finding the thirdmax, we are suppose to sort but we are not sorting here because it can be expensive for larger array, and here what we are just doing is initialising the new 3 var to math.MinInt64 and then when are greater than occurs num are swapped and given new values etc..........
- Adding strings, this is just the normal addition process where we carry through and all
- we are going to be using strings.FieldsFunc here that takes in (a string and a rune which is space, which is unicode.IsSpace) it seperates them and then we range through it with a count increment
- for arrange coins, we can use the gauss formula and also binary search and the bruteforce method, for the binary search we perform a calc m * (m + 1)/2 and if the calc is greater then we deduct r from m - 1 else our res = m also l = m + 1. we return res finally here. for the bruteforce we just perform some subtraction and addition
- for finding all duplicates here, we are going to use the absolute that kind of convert a nos to negative it is been seen and when it is seen again, we append the index
- for finding the missing number in an array or maybe the disappeared number, we are creating an array with the equal amount of lenth like the num array from the function. we range through and sort it, if there are nos that are not there they are given zero and then we know the disappeared number like that, we range through the res and create a counter also(the ocunter is used to know the amount of disappeared num in the array)
- assign cookies can be called a compare solution and that is why we need to sort before we run it through and from  sorting it we are all good to go.
- for finding the Hamming distance between two integers is the number of positions at which the corresponding bits are different, and we are going to do these by finding the XOR of the 2 number, then we initiate a count which we loop through and perform an AND operation  on it, we right shift it upon each loop
- Repeated string, we perform a kind of concaqtenation on the strings and that is by doubling it (from index 1 to index 0 : len - 1)  then we check if it contains the string in the concatenated string
- for finding the complement, we create a temp that is equial to 1 then we left it with 1 and the exclusive or it with 1, it is in a for loop the check till it is creater than the n created then xor the num and the newly created temp to give us our result
- for license formatting we are going firstly convert all the strings to Upper and the replace all "-" to space "", then we check for the mod between the len and the int. If we get 0, it means we divide it to equal part and then concatenate it
- for finding max consectuives one, we create 2 pointer that keep both nos of 1 and hte max nos of 1, at the end we do some checking and balancing
- for construct rectangle, we need to firstly find the square root of the area, then we range through it, then any where the area % sqrt is equal to 0 we return and if not we decrease by 1
- this is type of game whereby you have the time series you have to start and end in an array [the start, the end but this does not have end] so now the duration is being added to both side, let say for instance timeSeries[1,2] with duration 2, the person start at 1 and end at 2 then start at 2 again anf end at 4 the time used to fight is then 3
- for finding the next greater element we create a mao and a new array, the map stores the nums2 with there equivalent position in the array, then we go through the nums1 and then perform some math there
- for find word in a certain keyboard constant, we much first of all put all the keyboard const in a row(1,2,3) then we go through each word and each letter in the word and cross check it with the row, and if they are all in the same row we append to the new array res created
- we recursiv Inorder traversal here to find the mode(most frequently occured element)
- for finding the the base 7 of a num, it is the normal way we do it. you % and divide aand for the negative nos here we are going to convert to normal int and use concat to do the remaining
